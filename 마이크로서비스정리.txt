JAVA PERSISTENCE API
JPA 란?
JPA는 자바진영의 ORM 기술표준입니다. ORM이란 object-relational-mapping 객체와 관계형데이터베이스 매핑을 의미하는 것인데 하이버네이트(Hibernate) 오픈소스 ORM프레임워크를 기반으로 기술표준이 만들어진것이 JPA입니다. 

JPA의 장점
JPA를 사용하는 이유는 생산성, 유지보수, 성능 등을 꼽는데 우선 SQL문을 작성하지 않아도 된다는 점과 데이터베이스 중심 설계에서 객체 중심 설계로 변경됩니다. 그리고 DB컬럼이 추가될 때마다 테이블 수정이나 SQL 수정하는 과정이 없습니다. 그리고 같은 트랜잭션에 select가 여러번 호출된다면, 한번만 데이터베이스와 통신하고, 두번째부터는 조회한 객체를 재사용 합니다. 
그래서 가장 큰 장점 2가지를 꼽자면 생산성 향상(코드단위로만 알고 있어도 개발이 가능하고), DBMS가 변경된다 하더라도 소스, 특히 쿼리를 변경할 필요가 없습니다.(한번 설정한 DBMS를 바꿀일이 왠만하면 일어나진 않겠지만요.) 

JPA의 단점
반대로 단점은 다양한 쿼리작성이 힘들다는 점(오라클로 말하면 View 나 union all 등의 쿼리들), 그리고 데이터가 많이 쌓였을 경우 튜닝의 난해하기 때문에 성능상 문제가 발생할 수 있다는 것입니다. 한국에서는 잘 보이지 않지만 외국에서는 많이 보편화된 프레임워크입니다. 

빈 어노테이션은 기능은 같지만, DI 받는 객체의 성질에 따라서 다양한 이름으로 어노테이션을 제공한다.

 bean 어노테이션
적용 대상
 

 @Repository
 데이터 엑세스 계층의 DAO 또는 리파지토리 클래스에서 사용된다.
 DataAccessException 자동 변환과 같은 AOP의 적용 대상을 선정하기 위해서도 사용된다.
 즉, 데이터를 관리하는 Bean을 의미
 

 @Service
 서비스 계층의 클래스에 사용된다.

 @Controller
 프레젠테이션 계층의 MVC 컨트롤러에 사용된다.
 스프링 웹 서블릿에 의해 웹 요청을 처리하는 컨트롤러 빈으로 선정된다.

 스프링에 의해 관리되는 MVC의 Controller를 지칭

 @Component
 분류를 나누기 애매한 bean은 이곳으로 등록한다.

[출처] Bean 어노테이션|작성자 루미주인

 



ever note 정리 사항

리엑티브 마이크로서비스를 만드는 방법 두가지
1. 스프링프레임웍5에서 제공하는 스프링 웹플럭스(webFulx) 사용 - 리액티브 스타일의 웹서버를 마이크로서비스에 사용
   일반적인 옵져버(Observer) 패턴과 달리 리액티브 스트림에는 시퀀스의 처리, 완료 알림, 실배 시 배압(backpressure) 적용 등이 추가됨
   배압이 지원되면 받는 쪽에서는 보내는 쪽에 얼마만큼의 데이터를 소화할 수 있는 지 알릴 수 있다.
   받는 쪽에서는 데이타가 처리될 준비가 됐을 때만 데이터를 받을 수도 있다.
   리액티브 스트림은 서로 다른 컴포넌트 사이에 서로 다른 스레드 풀을 다뤄야 할 때나 느린 컴포넌트와 빠른 컴포넌트를 통합해야 할 때 많은 도움을 준다.
   
   리액티브 프로그래밍 원칙은 스프링 프레임워크 5의 핵심인 웹플럭스에 담겨 있다.
   스프링 5 웹플럭스는 리액티브 스트림 명세에 바탕을 두고 있다.
   스프링의 웹 리액티브 프레임워크는 리액터(Reactor) 프로젝트(http://projectreactor.io) 를 사용해서 리액티브 프로그래밍을 구현한다.
   리액터는 리액티브 스트림 명세의 구현체이다. 스프링 프레임워크를 사용하면 개발자는 리액터 대신에 알엑스자바(RxJava) 를 사용할 수 도 있다.
   * 리액티브 스트림 명세는 자바 9의 java.util.concurrent.Flux 패키지에 적용.
     플럭스 패키지에 사용되는 문법은 결과 값을 컬렉션화하는 람다식을 사용하는 자바 8의 completableFuture 와 비슷하다.
   스프링 5 리액티브는 RestTemplate.WebClient 의 대안으로서 완전한 리액티브를 지원하는 WebClient 와 WetTestClient 를 제공한다.
   WetTestClient   
	 
Mono와 Flux
우선 예제에 들어가기 앞서 Mono와 Flux의 차이점을 알 필요가 있습니다. Mono는 0-1개의 결과만을 처리하기 위한 Reactor의 객체이고, Flux는 0-N개인 여러 개의 결과를 처리하는 객체입니다. Reactor를 사용해 일련의 스트림을 코드로 작성하다 보면 보통 여러 스트림을 하나의 결과를 모아줄 때 Mono를 쓰고, 각각의 Mono를 합쳐서 여러 개의 값을 여러 개의 값을 처리하는 Flux로 표현할 수도 있습니다. 자세한 설명은 Reactor의 Mono reference와 Flux reference를 읽어 보시면 됩니다. 
Mono와 Flux모두 Reactive Stream의 Publisher 인터페이스를 구현하고 있으며, Reactor에서 제공하는 풍부한 연산자들(operators)의 조합을 통해 스트림을 표현할 수 있습니다. 예를 들어 Flux에서 하나의 결과로 값을 모아주는 reduce연산자는 Mono를 리턴하고, Mono에서 flatMapMany라는 연산자를 사용하면 하나의 값으로부터 여러 개의 값을 취급하는 Flux를 리턴할 수 있습니다. 그리고 Publisher인터페이스에 정의된 subscribe메서드를 호출함으로써 Mono나 Flux가 동작하도록 할 수 있습니다. 자세한 내용은 예제 코드를 통해 다루도록 하겠습니다.

******** Mono 와 Flux 사용하기 위해 필요한 maven 정보 *****************************
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-webflux</artifactId>
		</dependency>
*********************************************************************************		


   
   
2. 마이크로서비스 사이에 비동기적 상호작용에 레빗엠큐(RabbitMQ) 같은 메세징 서버를 사용

RabbitMQ를 실행한 화면

1. 얼랭 사이트에 들어가 얼랭 64bit 을 받는다. https://www.erlang.org/downloads  : erlang 먼저 설치한 뒤 rabbitMQ 설치
2. rabbitMQ 사이트에 들어가서 (https://www.rabbitmq.com/#getstarted) 다운로드 인스톨레이션을 클릭한 뒤 With installer (recommended) 이걸 클릭한다. 실수로 menual 들어가서 그대로 설치하면 삽질 할 수 있으니 With installer라고 적힌걸로 설치한다

rabbitMQ 관리자 페이지는 rabbitmq-plugins list 에서 rabbitmq_management 가 enable 되야 한다.
안되있으면 rabbitmq-plugins enable rabbitmq_management 활성화 한 후 restart 

rabbitMQ 관리자 페이지 : http://localhost:15672/#/ 




그래도 위 스크린샷에 나온 화면으로 들어갈 수 없으면 rabbitmq-plugins list 를 쳐보자 아마 플러그인이 enable이 되지 않아서일 것이다.

 그러면  rabbitmq-plugins enable rabbitmq_management 쳐본다.



이제 다시한번 rabbitmq-plugins list를 쳐보면 rabbitmq management가 enable이 된것을 볼수 있고 저 로컬호스트 포트로 들어가면 저 화면을 볼 수 있을 것이다

※ rabbitMQ 명령어 모음
   rabbitmqctl status 
   rabbitmq-plugins list
   rabbitmq-plugins enable rabbitmq_management

   
6장. 마이크로서비스 진화 사례 - 브라운필드 항공사 예제
  ★ 일체형 애플리케이션에서 마이크로서비스로 전환(Transition) 계획을 수립할 때 고려해야하는 관점들.
     1. 마이크로서비스 경계식별
	     - 규칙 : 마이그레이션 관점을 고려하고, 서비스를 분해. 분해 시 비지니스 범위나 경계 지어진 컨텍스트의 수준을 넘어서는 안된다.
		 - 의존관계분석 : 수동 코드 분석 및 의존 관계 재형성, 개발팀 경험을 이용해 의존 관계 재생성	    	 
	 2. 마이그레이션을 위한 마이크로서비스 우선순위 지정
	     - 의존관계 : 의존 관계 그래프는 우선 순위를 결정하는 데 도움이 될 수 있는 큰 요소이다.
		 - 트랜젝션 크기 : 트랜잭션 크기가 큰 서비스를 마이그레이션하면 현재 서비스의 로드를 줄여준다. 단 위험 부담도 크다는 단점이 있다.
		 - 리소스 이용율 : 리소스  이용율은 CPU, 메모리, 커넥션 풀, 스레드 풀 등의 이용율을 기반으로 측정된다. 리소스를 많이 사용하는 서비스를 마이그레이션하면
		                   남은 서비스들의 기능이 더 잘 작동할 수 있다
		 - 복잡도 : 복잡도는 비즈니스 로직과 관련된 서비스의 수, 테이블 수 ,코드 등으로 측정. 덜 복잡한 모듈은 복잡한 모듈에 비해 마이그레이션 하기 쉽다.
		 - 사업 중요도 : 사업 중요도는 수익이나, 고객의 경험에 기반을 두고 결정된다. 중요도가 높은 모듈일 수 록 더 높은 사업적 가지를 가진다.
		 - 변경속도 : 변경 속도는 짧은 시간 동안 해당 기능에 대해 얼마나 많은 변경 요구가 있는 지를 의미한다. 이를 변경 및 배포 속도와 민첩석으로 해석 할 수 있다.
		              변경 요구가 잦은 모듈은 안정적인 모듈에 비해 더 좋은 마이그레이션 후보이다.
		 - 혁신 : 파괴적 혁신 프로세스를 거치는 기능은 안정적인 비지니스 프로세스에 기반을 둔 백 오피스 기능에 비해 더 높은 우선 순위를 가진다.
	 3. 전환 단계에서의 데이터 통기화 처리
	    전환 단계 동안 레거시와 마이크로서비스는 병렬적으로 운영된다. 따라서 둘 간 데이타 동기화가 필요하다. 
		즉 레거시 RDB 와 마이크로서비스 NOSQL DB 간 비동기 처리 서비스를 구현하여, 데이터 동기화 한다. 반대도 마이크로서비스가 서비스를 만들어 제공한다.
	 4. 이전의 UI 와 새로운 UI 를 다루기 위한 사용자 Interfaee 통합
	    전이(Transition) 단계에서 레거시 UI 와 신규 UI 를 통합하는 과정이 필요하다. 이 때 세가지 방식이 존재한다.
		- 레거시UI ↔ 레거시 백엔드, 신규 UI ↔ 마이크로서비스 백엔드
		- 레거시UI 에서 신규 UI 로 페이지 이동. 이 때 SSO 가 구현되어 세션과 인증을 해줘야 한다.
		- 레거시UI ↔ 마이크로서비스 백엔드. 이 방법은 변화가 많이 필요해서 꽤 까다로울 수 있다.
		
		※ 레거시UI 에서 신규 UI 로 페이지 이동으로 처리하되 새로운 인증 서버를 구성하여 토근으로 유효성을 확인하는 방법이 적절 하다.
		   레거시 UI → 신규 UI 토근 전송, 신규 UI → 마이크로서비스 백엔드로 토큰 전송, 마이크로서비스 백엔드 → 신규 인증 서버 토큰 유효성 확인
	 5. 새로운 시스템에서의 참조 데이터 처리
	    일체형  애플리케이션을 마이크로서비스로 이전하는 과정에서 맞닥뜨리는 가장 큰 문제는 참조 데이타를 관리하는 것 이다. 참조 데이타를 마이크로서비스로 만드는 것도 간단한 예이다.
		하지만 모든 마이크로서비스가 참조 마이크로서비스를 종단점으로 접근하면 성능 문제가 발생할 수 있다. 따라서 이를 해결하기 위한 방법으로
		 - 각 마이크로서비스에 참조 데이타 API 와 참조 데이타 캐시를 구성하고 참조 마이크로서비스에서 비동기로 연동
		 - IMDG 를 사용하여 참조 데이타 공유
	 6. 비즈니스 범위가 제대로 유지될 수 있게 보장하는 테스트 전략
	     - 레거시와 마이크로서비스 동시에 테스트할 수 있는 전략이 필요하며 EJB 종단점 마다 하나의 테스트가 있어야 한다. 도한 REST 테스트 케이스도 필요하다.
	 7. 마이크로서비스의 기능, 프레임워크 등과 같은 마이크로서비스 개발을 위한 전제 조건 확인
	 
	★ chapter 6 예제 소스 분석 필요 ★
		기본적인 프로젝트 구조 설명
		1. component 패키지는 비즈니스 로직이 구현된 모든 서비스 컴포넌트를 포함하고 있다.
		2. controller 패키지는 rest 와 메세징 종단점을 포함하고 있따. 내부적으로 컨트롤러 클래스가 컴포넌트 클래스를 이용한다.
		3. entity 패키지는 데이터 베이스 테이블과 매핑된 JPA 엔티티 클래스를 포함하고 있다.
		4. repository 패키지는 스프링 데이터 JPA 에 기반을 둔 리파지토리 클래스가 들어있다.
	
   

7장. 스프링 클라우드 컴포넌트를 활용한 마이크로서비스 확장
  * 환경설정 외부화를 담당하는 스프링 컨피그 서버(config server)
  * 서비스 등록 및 탐색(discovery) 을 담당하는 유레카 서버(Eureka server)
  * 프록시 및 게이트웨이 역할을 담당하는 주울(Netflix Zuul)
  * 마이크로서비스 자동 등록 및 서비스 탐색의 구현
  * 비동기 리액티브 마이크로서비스 구성에 필요한 스프링 클라우드 메세징
  
  1. 스프링 클라우드 란
    스프링 클라우드 프로젝트는 스프링팀에서 만든 일종의 포괄적인 상위 프로젝트로, 분산 시스템 개발에 필요한 공통적인 패턴들을 모아
	사용하기 쉬운 스프링 라이브러리 형태로 구현해서 제공한다. 스프링 클라우드는 12 요소 애플리케이션 원칙을 준수하면서
	클라우드에 배포될 시스템을 개발할 때 필수적인 기능들을 제공한다.
	스프링 클라우드를 사용하면 개발자들은 분산, 장애 대응, 자제 치유 기능을 스프링 클라우드에 맡기고, 스프링 부트를 바탕으로 
	비지니스 기능을 만드는 데만 집중할 수 있다.
	스프링 클라우드 솔루션들은 배포 환경과 무관하게 사용될 수 있어서 일반 테스크톱 pc 환경과 탄력적인 클라우드 환경 모두에서 
	개발하고 배포할 수 있다. 스프링 클라우드로 개발된 클라우드용 솔루션은 클라우드 파운더리(cloud foundry), AWS, 허로쿠(Heroku) 에 
	무리없이 이관될 수 있다. 스프링 클라우드를 사용하지 않으면, 결국 클라우드 벤더에서 제공하는 서비스를 사용하게 되고, 이는 특정 PaaS 벤더의
	서비스와 높은 결합도를 형성하게 된다. 이를 피하려면 개발자가 직접 많은 양의 코드를 작성해야 한다.
	스프링 클라우드는 단순하고 사용하기 쉬운 스프링 친화적인 API 를 제공하는 데, 이런 API 는 AWS 의 알림 서비스와 같은 특정 벤더의 API 를 추상화 한다.
	
	※ 스프링 클라우드와 클라우드 파운드리의 차이점.
	   스프링 클라우드는 인터넷을 통해 들어오는 대규모의 다양한 요청을 처리할 수 있는 스프링 부트 애플리케이션을 만드는 데 사용되는 개발자 키트
	   클라우드 파운드리는 애플리케이션의 개발, 배포, 확정을 위한 오픈소스 PasS 플랫폼이라고 할 수 있다.
  
    ※ 12 요소 애플리케이션 - 허로쿠(Heroku)
	   클라우드 컴퓨팅은 비용,속도, 애자일성, 유연성, 탄력성 측면에서 많은 장점이 있다. 많은 클라우드 서비스 제공자들은 서로 다른 서비스를 제공하며 기업 고객들을 
	   더 많이 끌어들이기 위해 비용 모델을 낮추고 있다.
	   클라우드 네이티브 애플리케이션 개발을 할 때 필요한 원칙을 허로쿠(Heroku) 는 12 요소라고 정의 했다.
	   
	   1. 단일 코드 베이스 : 각 애플리케이션이 하나의 코드 베이스만 가져야한다. 즉 하나의 마이크로서비스는 하나의 코드베이스로 구성이되야 하며 개발, 테스트, 운영환경도 마찬가지로 구성이 필요하다.
	   2. 의존성 꾸러미(bundling dependencies) :  모든 애플리케이션은 필요한 모든 의존성을 하나의 꾸러미로 담아야한다. 메이븐이나 그레이들 같은 빌드 도구를 사용하면 pom.xml 이나 .gradle 파일에서
	                                              명시적으로 의존성을 관리 할 수 있고, 넥서스(Nexus)나 아카이바(Archiva) 같은 중앙 빌드 저장소를 이용해서 가져올 수 있다.
       3. 환경설정 외부화(externalization configurations) : 모든 환경설정 파라미터를 코드와 분리해서 외부화한다. 운영환경에 따라 달라지는 환경설정 정보는 외부화돼야 한다.
	   4. 후방지원 서비스 접근성(backing service) :  URL 을 통해 접근 가능해야 한다. 모든 서비스는 살아있는 실행 주기 동안 외부의 자원과 의사소통해야 한다. 즉 메세지나 이메일, 데이타베이스에 저장하는
	                                                 모든 외부 자원과의 커뮤니케이션은 URL 을 통해 접근 가능해야 한다.
       5. 빌드, 출시, 운영의 격리 : 각 환경별로 분리하여 단계별로 전파가 이루어 져야 한다
	   6. 무상태(stateless), 비공유 프로세스(shared nothing process) : 프로세스들이 상태가 없어야 하고 아무것도 공유하지 않는 것이 좋다. 만약 상태를 저장해야 하는 요구사항이 있다면 데이터 베이스나
                                                                       인메모리 캐시 같은 후방지원 서비스에서 처리 되야 한다.
       7. 서스를 포트에 바인딩해서 노출 : 자기 완비적이거나 독립 설치형어야 한다. 전통적인 애플리케이션은 웹서버나 was 에 배포가 된다. 마이크로서비스에서는 외부 웹서버에 의존하지 않는 다.
	                                      톱캣이나 재티 같은 http 리스너는 서비스나 애플리케이션 자체에 내장돼야 한다. 포트 바인딩은 마이크로서비스가 자율적으로 자기 완비적인 특성을 유지하는 필수요소다.
       8. 확장을 위한 동시성 : 확장을 위한 동시성 원칙은 복제(replicating) 를 통해 프로세스가 확정될 수 있게 설계해야 한다. 이는 프로세스 내부에서 추가적인 스레드를 사용한다는 의미이다.
	                           마이크로서비스 세상에서는 서비스가 서버의 자원을 늘리는 수직적 확장(scale up) 이 아니라 서버수를 늘리는 수평적 확장(scale out) 방식으로 확장된다.
       9. 폐기 영향 최소화(disposalbility with minimal overheadr) : 애플리케이션 시동과 종료에 필요한 시간을 최소화하고, 서버가 종료될 때에는 종료에 필요한 작업이 모두 수행되는 우아한 방식으로 
		                                                             종료되게 만들어야 한다. 
      10. 개발과 운영의 짝맞춤 : 개발과 운영 환경을 동일하게 유지해야 한다.																	 
	  11. 로그 외부화 : 로그 파일을 자기 자신안에 담지 않는 다. 클라우드에서는 로컬 I/O 를 피하는 것이 상책이다. I/O 가 충분히 빠르지 않다면, 중앙 집중식 로깅 프레임워크를 사용하는 게 좋다.
	                    스플렁크(splunk), 그레이로그(Graylog), 로그스태쉬(Logstash), 로그플렉스(Logplex), 로글리(Loggly) 등 이다. logback appender 를 통해 중앙 저장소에 적재한다.
관리자 프로세스 패키징 : 관리자용 타스크는 애플리케이션 본연의 서비스를 실행하는 프로세스와 동일한 환경에서 실행되야 한다. 즉 관리자용 콘솔을 제공해야 한다.						

 2. spring config server 
    ①  spring starter project 에서 config server 와 actuator 를 선택
	② 원래 git 서버를 통해 config 파일을 관리하나, 현재 테스트를 위해 local git 에 저장소를 생성 한다.
        PS C:\config-repo> git init
           Initialized empty Git repository in C:/config-repo/.git/
        PS C:\config-repo> echo message : helloworld > application.properties
        PS C:\config-repo> git add -A
        PS C:\config-repo> git commit -m "Added sample application.properties"	
	③ application.properties 파일을 bootstrap.properties 으로 변경
        server.port=8888
        spring.cloud.config.server.git.uri=https://github.com/subprovider/sts-config.git → 로컬 git 설정은 file://C:/config-repo 이렇게.		
        management.security.enabled=false
		→ 8888 포트는 기본적으로 config 서버가 사용하는 기본 포트이다. 8888 포트를 명시하지 않아도 기본적으로 8888 프트에서 실행된다.
		  윈도우 환경에서는 URL 의 맨 끝에 /를 추가해줘야 한다. management.security.enabled=false 를 추가해서 보안 검증을 비활성화 한다.
        spring.application.name = kosOrdApp → application 명을 변경하고 싶으면 이렇게 변경한다.
    ④ application.java 의 @SpringBootApplication 위에 @EnableConfigServer 라는 어노테이션을 추가한다.		  
       @SpringBootApplication
       @EnableConfigServer
       public class ConfigServerApplication {		  
	⑤ http://localhost:8888/{name}/{profiel}/{lable} 이런식으로 config server URL 이 구성 된다.
	   {name} : application name 이다. 각 애플리케이션은 고유한 이름을 가져야 한다. 컨피그 서버는 컨피그 서버 저장소에서 이 이름에 밎는 환경설정 정보를 찾는 다. 
	            애플리케이션 이름은 종종 서비스 id 로 불리기도 한다.
	   {profile} : 하나의 애플리케이션에 대한 환경설정 정보파일에는 여러 개의 프로파일이 존재할 수 있다. 프로파일은 다양한 시나리오에 사용되는 데, 대표적인 사례는
                   개발환경을 dev, test, stage, prod 로 나누는 방식과 서버 환경설정 정보를 primary, secondary 등으로 나누는 방식이다.	   
				   전자는 동일한 애플리케이션의 서로 다른 환경을 의미하고, 후자는 애플리케이션이 배포될 서로 다른 서버를 의미 한다.
				   프로파일 이름은 저장소에서 파일이름을 매칭하는 데 사용되는 논리적인 이름이다. 기본 프로파일은 deafult 이다. 서로 다른 환경에 대한 환경설정 정보를 사용하려면
				   서로 다른 이름의 환경설정 정보 파일을 작성해야 한다.
				   kosOrdApp-dev.properties, kosOrdApp-sit.properties
				   http://localhost:8888/kosOrdApp/dev,  http://localhost:8888/kosOrdApp/sit

	   {label} : 레이블의 기본 값은 master 이다. 레이블은 필수가 아닌 옵션 정보이며, git 의 브렌치 이름이 레이블로 사용된다.
                 http://localhost:8888/kosOrdApp/default, http://localhost:8888/kosOrdApp/master, http://localhost:8888/kosOrdApp/default/master 모두 동일한 환경설정 정보 파일이다.
			 
 3. spring client server 
	①  spring starter project 에서 config client 와 actuator 를 선택 또한 아래 dependency 가 없으면 추가
	<dependencyManagement>
		<dependencies>
			<dependency>
				<groupId>org.springframework.cloud</groupId>
				<artifactId>spring-cloud-dependencies</artifactId>
				<version>${spring-cloud.version}</version>
				<type>pom</type>
				<scope>import</scope>
			</dependency>
		</dependencies>
	</dependencyManagement>	
	② bootsrtap.property 파일 작성
	   - spring.application.name = kosOrdApp  ← github 에서 참조할 {name} 명 즉 애플리케이션명
	   - spring.cloud.config.uri=http://localhost:8888 ← config 서버 주소
	③ controller class 에 @RefreshScope 추가
       - Spring boot 2.x 부터는 Spring boot actuator 를 이용해 POST 방식으로 end point 를 호출을 해주어야 적용이 된다. 
	    여기서는 http://localhost:8081/actuator/refresh 를 curl이나 postman 등의 rest client 툴을 활용해 post 방식으로 호출해주어야 적용 된다.
	   - 또는 $ curl localhost:8082/actuator/refresh -d {} -H "Content-Type: application/json" 방식으로 호출이 가능하다.
	   
4. spring cloud bus (page 347 참조)
   - 위 client server 처럼 인스턴스 별로 refresh 종단점 (end point) 를 호출해줘야 하는 데, 인스턴스가 많을 때는 매우 귀찮은 일이다. 
     이를 해결하기 위해 스프링 클라우드 버스가 이 문제를 해결해 줄 수 있다.
	 즉 메세지 브로커를 두어 각 인스턴스가 구독 하게 되면 환졍 설정 파일들이 모든 인스턴스에 적용될 수 있게 된다.
	 각 인스턴스는 하나의 메세지 브로커를 통해 ㅂ녀경 이벤트를 구독하고, 변경 이벤트가 발생하면 각 인스턴스는 변경된 환경설정 정보를 새로 읽어 와서
	 로컬에 캐시돼 있는 환경설정 정보를 업데이트 한다. 어떤 인스턴스 하나의 /bus/refresh 종단점이 호출되면 클라우드 버스와 공통의 메세지 브로커를 통해
	 변경이 모두에게 전파 된다.
	 
	 
5. 컨피그 서버에 고가용성 적용(page 348 참조)
  * failover : 동작 중인 서버에 장애가 발생할 때 곧바로 여분의 다른 서버가 서비스 요청을 처리하게 만드는 기능. 무정지 장애 대응
  * fallback : 장애가 발생한 서버가 복구되면 그 이후에 들어오는 서비스의 요청을 복구된 원래의 서버가 처리하게 만드는 기능. 무정지 원상 복구
  - config server 는 단일 장애 지점(single point of failure) 이기도 하다, 
    컨피그 서버에 장애가 발생할 수 있기 때문에 컨피그 서버에 대한 고가용성이 필요하다. 
	즉 컨피그 서버와 같은 환경설정과 관련된 애플리케이션 정보는 로드발렌서 나 로컬 DNS 에 저장돼야 한다. 이 경우 로드 배렌서나 DNS 섭서의 URL 이 각 애플리케이션의 bootsrtap 파일에
	저장되야 한다.
  ※ 환경설정 정보 저장소의 고가용성에 대한 github 예제 정보
     https://about.github.com/high-availability/
  ※ 레빗엠큐의 고가용성 공식 문서
     https://www.rabbitmq.com/ha.html
	 
6. 컨피그 서버 상태 모니터링 및 환경설정 파일들이
  - 컨피그 서버 상태는 액추에이터 종단점 http://localhost:8888/health 를 통해 확인이 가능하다.
  - 환경설정을 외부화 하다보면 logback.xml 처럼 완전한	파일 전체를 외부화 해야 할 때도 있다. 컨피그 서버는 아래와 같은 URL 에 접근해서 환경설정 파일 내 정보를 관리할 수 있다.
     /{애플리케이션명}/{프로파일}/{레이블}/{경로} ← {경로} 에는 logback.xml 같은 파일 이름이 들어간다.
	 
7. 유레카를 이용한 서비스 등록 및 탐색
   - 리본(Ribbon) 기반의 부하 분산은 대부분의 마이크로서비스 환경에서는 충분히 쓸만하지만 다음과 같은 사용 사례에서는 한계가 들어난다.
     * 인프라스트럭처의 최적화가 필요하여 인스턴스의 개수와 관련된 서버의 개수를 동적으로 조절해야 할 때 예측을 통해 서버의 URL 을 환경설정 파일에 정적으로 미리 지정하는 것은 적합하지 않다.
     * 고가용성 마이크로서비스를 위해 클라우드의 배포를 목표로하고 있다면, 서비스를 정적으로 등록하고 찾는 것은 좋치 않다.
     * 클라우드 배포 시나리오에서 IP 주소는 예측할 수 없으며, 파일에서 정적으로 관리하기 어렵다.

   - 동적 서비스 등록 및 탐색의 이해 : 유레카
     유레카는 자기 등록(self-registration), 동적 탐색 및 부하 분산에 주로 사용되며 부하 분산을 위해 내부적으로 리본을 사용한다.
	 유레카 서버와 클라이언트 서버로 구성되있으며, 서버에 등록되면 유레카 서버 레지스트리에 30초 간격으로 ping 요청을 날리면서 health 체크를 한다.
	 유레카 클라이언트는 서버로부터 레지스트리 정보를 읽어와 로컬에 캐시한다. 그리고 나서 클라이언트는 로컬에 캐시된 레지스트리 정보를 이용해서 필요한 다른 서비스를 찾을 수 있게 된다.
     이 정보는 30초 마다 주기적으로 갱신되며, 최근에 가져온 정보와 현재 레지스트리 정보의 차이를 가져오는 방식(delta udpates) 으로 갱신된다.
	 클라이언트가 마이크로 서비스 종단점에 접속하려고 하면 유레카 클라이언트는 요청된 서비스 id 기준으로 현재 사용 가능한 서비스의 목록을 제공한다.
	 유레카 서버는 zone 정보를 알고 있다. zone 정보는 서비스를 등록할 때 제공 받을 수 있다.
	 클라이언트가 서비스 인스턴스에 요청을 보내면 유레카 서비스는 동일한 zone 내 에서 실행되고 있는 서비스를 찾는 다. 리본 클라이언트는 유레카 클라이언트가 알려주는 사용 가능한 
	 서비스 인스턴스들에게 요청을 분산해서 보내는 방식으로 부하 분산을 실행한다. 유레카 클라이언트와 서버 사이의 커뮤니케이션은 rest 와 json 이 사용된다.
	 

	 

	 
	
  